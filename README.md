# What is this project?

This project is an IDE for the language AWN. It is a VSCode extension that utilises Microsoft's Language Server Protocol.

# What is a Language Server?

This project is a "language server", a program which creates an IDE environment based on a language (in this case, AWN), using Microsoft's Language Server Protocol (LSP), an abstract protocol that describes using a programming language in an IDE. For example, the protocol specifies syntax highlighting, autocompletion, and so on. The idea is that, because LSP is abstract, it can be implemented into any IDE, regardless of the language used in the backend of that IDE.

Obviously, no language server already exists for AWN, so this project is a language server for AWN. 
VSCode understands LSP - it allows LSP language servers to be extensions, which is what is done here.

The language server consists of two parts (which are each their own node.js packages): 
- The client, which interacts with the user directly, and is very light. It sends requests off to the server when the user requires information.
- The server, which is independent of the user, but is interacted with through the client. The server does all the calculations, such as building an AST, and so on.

The language server as a whole is also a node.js package.

# How syntax highlighting and semantic checking works, at a very high level

This section explains the steps for how the "server" part of the language server works. The whole process is one pipeline.

In preparation, a grammar for AWN is defined in ```awn-grammar.peg```, which is then used to create ```parser.ts``` automatically. This file also contains an (abstract) AST, but this AST is insufficient for the final product*, and is referred to as the "proto-AST". The final-form AST is defined in ```ast.ts```.

When the user edits an open ```.awn``` file, the following steps are processed in order:

1. The ```.awn``` file is converted into a proto-AST by ```parser.ts```.
2. ```convertAST.ts``` converts the proto-AST into the final-form AST.
3. ```check.ts``` checks the AST for semantic errors, and sets info that couldn't be done at parse time such as typing.
4. ```semanticTokens.ts``` takes the checked AST and outputs syntax highlighting tokens ("semantic tokens" - LSP's implementation of syntax highlighting). It will highlight as best as it can given any semantic errors present.

If there is a syntax or semantic error, an error message is sent to the terminal.

*Insufficient due to a few reasons - it has unnecessary info, arrays are represented as a chain of parent-child, as are lists of binary operators, which makes the precedence info very annoying to decode.

## Project Structure

```
.
├── client // Language Client
│   ├── src
│   │   ├── test // End to End tests for Language Client / Server
│   │   └── extension.ts // Language Client entry point
├── server // Language Server
│   └── src
│       ├── ast.ts // Abstract Syntax Tree for AWN
│       ├── awn-grammar-original.peg // "original" AWN grammar - kept for reference, more readable as a grammar
│       ├── awn-grammar.peg // AWN grammar with left-recursion removed & necessary code inserts - this grammar actually used by the parser
│       ├── check.ts // semantic checking of a generated AST
│       ├── convertAST.ts // converts the proto-AST generated by parser.ts into the final AST defined in ast.ts
│       ├── parser.ts // PEG grammar parser (autoconverted to .ts for compatibility) - uses awn-grammar.peg to convert a .awn file into an AST (referred to as the proto-AST)
│       ├── semanticTokens.ts // returns semantic highlight information to the client when it is requested
│       ├── server.ts // Language Server entry point
│       └── syntaxError.ts // Generates nicer-looking syntax errors
└── tests // Contains test .awn files, also the actual .awn files i was sent
```

## Running the Language Server

- Install [VSCode.](https://code.visualstudio.com/download)
- Open this folder in VSCode.
- Install node.js and npm, which come together. You can check if you have them already by running `node -v` and `npm -v`.
	- On Windows, install [here.](https://nodejs.org/en)
	- On Mac, if you have Homebrew, run `brew install node`
	- On Linux, run `sudo apt install nodejs npm`
- Run `npm install` in this folder. This installs all necessary npm modules in both the client and server folder.
- Press ▷ to run the launch config (F5), creating a new instance of VSCode that runs this extension.
- In this new instance of VSCode, open a .awn file inside `\tests`, for example.
- If the language server crashes quickly a few times, it will need to be restarted with Ctrl+R.

## Things changed about the AWN Grammar

I changed a few things about the AWN grammar (either because they were impossible to implement or would have added a lot of complexity):

1. Originally, infix funcs were defined in the format ```InfixName: TE``` where ```InfixName``` is a string of the following characters: ```*+-:<=>!&|```. Having ```:``` here causes parsing issues, so I have changed this to allow InfixName to be either a string of the other characters or a single ```:``` on its own.

2. The ```unicast(DE, DE)``` and ```groupcast(DE, DE)``` primitives have been changed to ```unicast(DE; DE)``` and ```groupcast(DE; DE)``` to distinguish their separator from the DE construction ```DE = DE, DE, ..., DE```.

3. I have removed the prefix function application construction ```DE DE```; functions are now always written as ```DE(DE)```. The only time this was used in the files I was given was for negation ```!```.

I've edited the ```.awn``` files I was given (in ```server/tests/Examples```) to conform to these new rules.

## Known Problems and Next Steps

The IDE is not great when there are syntax errors, as all highlighting disappears and the error message it gives is only somewhat helpful. This happens because the parser generated by the parser generator does not return anything (except the error message) when there is an error. Unless I found a different parser generator (which would also require ```convertAST.ts``` to be re-written), I wanted to improve this by only sending a delta of semantic tokens (relative to the last syntactically correct version) if a syntax error occurred, where the newly incorrect tokens can simply be unhighlighted.

Two features that could be fairly easily added to the IDE are 1) jump-to-definition and 2) having the comment alongside a declaration appear in the hover information for that declaration.