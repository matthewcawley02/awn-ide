\documentclass[adraft]{eptcs}
\usepackage{latexsym,breakurl,amsmath,amssymb}
\usepackage[shortlabels]{enumitem}
\usepackage{xcolor}
\setlist[enumerate]{nosep}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%				Characters			          %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newfont{\bbb}{bbm10 scaled 1100}                       % blackboard bold
\newcommand{\IN}{\mbox{\bbb N}}                         % natural numbers
\newcommand{\denote}[1]{\mbox{\bbb [}#1\mbox{\bbb ]}}   % denotation
\DeclareSymbolFont{frenchscript}{OMS}{ztmcm}{m}{n}
\DeclareMathSymbol{\A}{\mathord}{frenchscript}{65}      % alphabet of target language
\DeclareMathSymbol{\B}{\mathord}{frenchscript}{66}      % alphabet of parser language
\DeclareMathSymbol{\C}{\mathord}{frenchscript}{67}      % constructors
\DeclareMathSymbol{\E}{\mathord}{frenchscript}{69}      % alphabet of parsed language
\DeclareMathSymbol{\G}{\mathord}{frenchscript}{71}      % word generators
\DeclareMathSymbol{\N}{\mathord}{frenchscript}{78}      % nonterminals
\DeclareMathSymbol{\pow}{\mathord}{frenchscript}{80}    % powerset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\sect}[1]{Section~\ref{sec:#1}}
\newcommand{\aac}[1]{{\tt #1}}    % official ASCII AWN code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\chP}[1]{\textcolor{red}{#1}}
\newcommand{\chR}[1]{\textcolor{magenta}{#1}}

\def\titlerunning{A Machine Readable Syntax for AWN Specifications}
\title{\titlerunning}
\author{Rob van Glabbeek
\institute{Data61, CSIRO, Sydney, Australia}
\institute{School of Computer Science and Engineering,
University of New South Wales, Sydney, Australia}
\email{rvg@cs.stanford.edu}
}
\def\authorrunning{R.J. van Glabbeek}
\begin{document}
%\maketitle

\section{The parsing problem}

Assume three finite alphabets $\A$, $\B$ and $\E$, for the \emph{target language}, the
\emph{parser language} and the \emph{parsed language}. Neither may contain the white-space;
$\B$ may not contain quotes, and $\E$ may not contain the four characters {\tt (}, {\tt |}, {\tt )} and {\tt ,}.

Let $\textbf{words}\subseteq \A^+$ be a given nonempty set of strings over $\A$.
A \emph{sentence} is a nonempty sequence of words.
A \emph{grammar} is a tuple $(\C,S,\G,\denote{\_\!\_\,},P)$ with $\C\subseteq_{\rm fin} \B^+$, the \emph{constructors},
$S\in C$, the \emph{initial constructor}, $\G\subseteq_{\rm fin} \B^+$, the \emph{word generators},
$\denote{\_\!\_\,}: \G \rightarrow \pow(\textbf{words})$,
a function that associates with each word generator a set of words,
and $P$ a finite set of \emph{productions}, to be defined below.
Call $\N := \C \uplus \G$ the set of \emph{nonterminals}.
Each production is a tuple
\begin{center}
  ($C$, \textit{body}, \textit{name}, \textit{direction}, \textit{priority})
\end{center}
with $C\in \C$ a constructor,
$\textit{body} \in (\N \uplus \{`w\mbox{'}\mid w \in \textbf{words}\})^+$ a nonempty sequence of
non-terminals and quoted words, \textit{name} a string of symbols over $\E$,
$\textit{direction} \in \{\textit{left},\textit{right},\textit{none}\}$
and
$\textit{priority} \in \IN$. Each production must have a unique name.

Most definitions that follow are in the context of a given grammar.
I rule out \emph{circular} grammars, those with constructors $C_1, \dots, C_{n-1},C_n$ and bodies
$C_2, \dots, C_n, C_1$, respectively.

For each production $\rho\in P$, we write 
$C_\rho$, $\textit{body}_\rho$, $\textit{name}_\rho$, $\textit{direction}_\rho$ and
$\textit{priority}_\rho$ for its components.
The \emph{arity} $\textit{ar}(\rho)$ of $\rho$ is the number of nonterminals in $\textit{body}_\rho$.
The \emph{type} of $\rho$ is $C_\rho$.

A \textbf{parse tree} of type $N\in \N$ is inductively defined as follows.
\begin{itemize}
\item If $g\in \G$ and $w\in \denote{g}$, then $g(w)$ is a parse tree of type $g$.
\item If $C\in \C$, $\rho\in P$ has type $C$, and $\pi_i$ is a parse tree of type $N_i$ for each
  $1\leq i \leq \textit{ar}(\rho)$ such that $N_i$ is the $i^{\rm th}$ nonterminal in $\textit{body}_\rho$,
  then $\textit{name}_\rho(\pi_1,\dots,\pi_{\textit{ar}(\rho)})$ is a parse tree of type $C$. 
\end{itemize}
Each parse tree $\pi$ determines a sentence $\denote{\pi}$ as follows:
\begin{itemize}
\item If $\pi = g(w)$ for $g\in\G$, then $\denote{\pi}=w$.
\item If $\pi = \textit{name}_\rho(\pi_1,\dots,\pi_{\textit{ar}(\rho)})$, then $\denote{\rho}$ is obtained by
  from the sequence $\textit{body}_\rho$ by replacing each quoted word $`w\mbox{'}$ by $w$, and, for
  $1\leq i \leq \textit{ar}(\rho)$, replacing the $i^{\rm th}$ nonterminal by $\denote{\pi_i}$.
\end{itemize}
If $\denote{\pi}=\sigma$, for $\sigma$ a sentence, then $\pi$ is called a parse tree \emph{of} $\sigma$.
A sentence \emph{parses} iff it has a parse tree.
A \emph{parsing algorithm} must return for any given sentence either $\bot$, indicating that no
parse tree could be found, or a parse tree of that sentence, or a \emph{witness for ambiguity}.
The latter is like a parse tree, but with one more more subtrees $\pi'$ of type $N$ replaced by an
expression $\pi_1 \mid \pi_2$, with $\pi_1$ and $\pi_2$ both parse trees of type $N$, and such that
taking either alternative yields a valid parse tree of the sentence.
The algorithm is \emph{complete} iff it returns $\bot$ only when the input sentence does
not parse.

\section{Notes}

Classical context-free grammars just generate words as sequences of characters.
Here we instead have two layers: a word is a sequence of characters, and a sentence a sequence of words.
Does this corresponds with the perspective of rats or sbt-rats?

As the (context-free or regular) generation of words out of characters is rather unproblematic, in
my description of the parser problem I have taken it for granted.

You say that PEG cannot be ambiguous. Is this the same for sbt-rats? I.e.\ could it ever admit
multiple, equally plausible parse trees or not?

Can the behaviour of sbt-rats be seen as a parsing algorithm as defined above?

\section{A solution to the parsing problem}

For $\sigma$ a sentence, let $|\sigma|$ denote the number of words in $\sigma$,
$\sigma_{\leq j}$ for $1 \leq j < |\sigma|$ is the sentence consisting of the first $j$
words of $\sigma$, and $\sigma_{>j}$ is what is left of $\sigma$ after deleting $\sigma_{\leq j}$.
$\sigma_{\geq j}$ and $\sigma_{< j}$ are defined likewise.

If $\Lambda  \in (\N \uplus \{`w\mbox{'}\mid w \in \textbf{words}\})^+$ and $N \in N$ then
$N:\Lambda$ is the sequence obtained from $\Lambda$ by appending $N$ on the left.
Likewise $\Lambda:N$ appends $N$ on the right.

I recursively define subroutines $\textit{parseR}(\sigma,\Gamma)$ and $\textit{parseL}(\sigma,\Gamma)$,
taking as inputs a sentence $\sigma$ and a string $\Gamma \in (\N \uplus \{`w\mbox{'}\mid w \in \textbf{words}\})^+$,
and returning either value $\bot$ or a (possibly empty) comma-separated list of parse trees.
Simultaneously I define a subroutine  $\textit{parse}(\sigma,N)$, taking as input a sentence $\sigma$
and a nonterminal $N\in\N$, and returning either $\bot$ or a parse tree.
Here ``parse trees'' might also be witnesses for ambiguity.
The parsing algorithm $\textit{parse}(\sigma)$, taking as input just a sentence $\sigma$, is then
defined as $\textit{parse}(\sigma,S)$.
\vspace{2ex}

\noindent
\begin{minipage}{3in}
$\textit{parseR}(\sigma,\Gamma)$ :=\\ \mbox{}
\quad \textbf{if} $(\Gamma=N\in\N)$ \textbf{then} \\ \mbox{}
\quad \quad return$(\textit{parse}(\sigma,N))$ \\ \mbox{}
\quad \textbf{elsif} $(\Gamma=`w\mbox{'})$ \textbf{then} \\ \mbox{}
\quad \quad \textbf{if} $(\sigma = w)$ \textbf{then} return($\varepsilon$) \textbf{else} return($\bot$) \\ \mbox{}
\quad \textbf{elsif} $(\Gamma= `w\mbox{'} : \Lambda)$ \textbf{then} \\ \mbox{}
\quad \quad \textbf{if} $(|\sigma| > 1 \wedge \sigma_{\leq 1} = w)$ \textbf{then} \\ \mbox{}
\quad \quad \quad return$(\textit{parseR}(\sigma_{> 1},\Lambda))$ \\ \mbox{}
\quad \quad \textbf{else} return($\bot$) \\ \mbox{}
\quad \textbf{elsif} $(\Gamma= N : \Lambda)$ \textbf{then} \\ \mbox{}
\quad \quad  $\textit{head} := \bot$; \\ \mbox{}
\quad \quad  $j:=1$; \\ \mbox{}
\quad \quad  \textbf{while} $j < |\sigma|$ \textbf{do} \\ \mbox{}
\quad \quad \quad $\textit{head} := \textit{parse}(\sigma_{\leq j},N)$; \\ \mbox{}
\quad \quad \quad  \textbf{if} $\textit{head}=\bot$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad $j:=j+1$; \\ \mbox{}
\quad \quad \quad  \textbf{else}  \\ \mbox{}
\quad \quad \quad \quad $\textit{tail} := \textit{parseR}(\sigma_{> j},\Lambda)$; \\ \mbox{}
\quad \quad \quad \quad  \textbf{if} $\textit{tail}=\bot$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad \quad $j:=j+1$; \\ \mbox{}
\quad \quad \quad \quad  \textbf{else}  \\ \mbox{}
\quad \quad \quad \quad \quad $j:=|\sigma|$; \\ \mbox{}
\quad \quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \textbf{od}; \\ \mbox{}
\quad \quad  \textbf{if} $\textit{head}=\bot$ \textbf{then} return($\bot$) \\ \mbox{}
\quad \quad  \textbf{elsif} $\textit{tail}=\bot$ \textbf{then} return($\bot$) \\ \mbox{}
%\quad \quad  \textbf{elsif} $\textit{head}=\epsilon$ \textbf{then} return(\textit{tail}) \\ \mbox{}
\quad \quad  \textbf{elsif} $\textit{tail}=\epsilon$ \textbf{then} return(\textit{head}) \\ \mbox{}
\quad \quad  \textbf{else} return(\textit{head},\,\textit{tail}) \\ \mbox{}
\quad \textbf{fi} \\ \mbox{}
\end{minipage}
\hfill
\begin{minipage}{3in}
$\textit{parseL}(\sigma,\Gamma)$ :=\\ \mbox{}
\quad \textbf{if} $(\Gamma=N\in\N)$ \textbf{then} \\ \mbox{}
\quad \quad return$(\textit{parse}(\sigma,N))$ \\ \mbox{}
\quad \textbf{elsif} $(\Gamma=`w\mbox{'})$ \textbf{then} \\ \mbox{}
\quad \quad \textbf{if} $(\sigma = w)$ \textbf{then} return($\varepsilon$) \textbf{else} return($\bot$) \\ \mbox{}
\quad \textbf{elsif} $(\Gamma= \Lambda : `w\mbox{'})$ \textbf{then} \\ \mbox{}
\quad \quad \textbf{if} $(|\sigma| > 1 \wedge \sigma_{\geq |\sigma|} = w)$ \textbf{then} \\ \mbox{}
\quad \quad \quad return$(\textit{parseL}(\sigma_{< |\sigma|},\Lambda))$ \\ \mbox{}
\quad \quad \textbf{else} return($\bot$) \\ \mbox{}
\quad \textbf{elsif} $(\Gamma= \Lambda : N)$ \textbf{then} \\ \mbox{}
\quad \quad  $\textit{head} := \bot$; \\ \mbox{}
\quad \quad  $j:=|\sigma|$; \\ \mbox{}
\quad \quad  \textbf{while} $j > 0$ \textbf{do} \\ \mbox{}
\quad \quad \quad $\textit{head} := \textit{parse}(\sigma_{\geq |\sigma|},N)$; \\ \mbox{}
\quad \quad \quad  \textbf{if} $\textit{head}=\bot$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad $j:=j+1$; \\ \mbox{}
\quad \quad \quad  \textbf{else}  \\ \mbox{}
\quad \quad \quad \quad $\textit{tail} := \textit{parseL}(\sigma_{< |\sigma|},\Lambda)$; \\ \mbox{}
\quad \quad \quad \quad  \textbf{if} $\textit{tail}=\bot$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad \quad $j:=j+1$; \\ \mbox{}
\quad \quad \quad \quad  \textbf{else}  \\ \mbox{}
\quad \quad \quad \quad \quad $j:=0$; \\ \mbox{}
\quad \quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \textbf{od}; \\ \mbox{}
\quad \quad  \textbf{if} $\textit{head}=\bot$ \textbf{then} return($\bot$) \\ \mbox{}
\quad \quad  \textbf{elsif} $\textit{tail}=\bot$ \textbf{then} return($\bot$) \\ \mbox{}
%\quad \quad  \textbf{elsif} $\textit{head}=\epsilon$ \textbf{then} return(\textit{tail}) \\ \mbox{}
\quad \quad  \textbf{elsif} $\textit{tail}=\epsilon$ \textbf{then} return(\textit{head}) \\ \mbox{}
\quad \quad  \textbf{else} return(\textit{tail},\,\textit{head}) \\ \mbox{}
\quad \textbf{fi} \\ \mbox{}
\end{minipage}
\newpage

\noindent
$\textit{parse}(\sigma,N)$ :=\\ \mbox{}
\quad \textbf{if} $(N\in\G)$ \textbf{then} \\ \mbox{}
\quad \quad \textbf{if} $(|\sigma| =1 \wedge \sigma \in \denote{N})$ \textbf{then} return($N(\sigma)$) \\ \mbox{}
\quad \quad \textbf{else} return($\bot$) \\ \mbox{}
\quad \textbf{elsif} $(N\in \C)$ \textbf{then} \\ \mbox{}
\quad \quad $\textit{outcome} := \bot$; \\ \mbox{}
\quad \quad $\textit{alt} := \bot$; \\ \mbox{}
\quad \quad $p=\max(\{\textit{priority}_\rho \mid \rho \in P\})$; \\ \mbox{}
\quad \quad \textbf{while} ($\textit{outcome} = \bot \wedge p\geq 0$) \textbf{do} \\ \mbox{}
\quad \quad \quad \textbf{for each} $\rho \in P$ \textbf{do} \\ \mbox{}
\quad \quad \quad \quad  \textbf{if} $(C_\rho = N \wedge \textit{alt} = \bot \wedge \textit{priority}_\rho = p)$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad $\textit{right} := \textit{parseR}(\sigma,\textit{body}_\rho)$ \\ \mbox{}
\quad \quad \quad \quad .\quad $\textit{left} := \textit{parseL}(\sigma,\textit{body}_\rho)$ \\ \mbox{}
\quad \quad \quad \quad .\quad  \textbf{if} $(\textit{right} \neq \bot)$  \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad  \textbf{if} $(\textit{outcome} = \bot)$  \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad  \textbf{if} $(\textit{direction}_\rho = \textit{right})$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad $\textit{outcome} := \textit{name}_\rho(\textit{right})$ \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad  \textbf{elsif} $(\textit{direction}_\rho = \textit{left})$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad $\textit{outcome} := \textit{name}_\rho(\textit{left})$ \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad  \textbf{elsif} $(\textit{direction}_\rho = \textit{none})$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad $\textit{outcome} := \textit{name}_\rho(\textit{right})$ \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad \textbf{if} $(\textit{left} \neq \textit{right})$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad \quad $\textit{alt} := \textit{name}_\rho(\textit{left})$; \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \textbf{else} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad  \textbf{if} $(\textit{direction}_\rho = \textit{right})$ \textbf{then} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad .$\textit{alt} := \textit{name}_\rho(\textit{right})$ \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad  \textbf{else} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \quad .$\textit{alt} := \textit{name}_\rho(\textit{left})$ \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \quad .\quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \quad .\quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \quad \textbf{fi} \\ \mbox{}
\quad \quad \quad \textbf{od}; \\ \mbox{}
\quad \quad \quad $p:= p-1$; \\ \mbox{}
\quad \quad \textbf{od}; \\ \mbox{}
\quad \quad \textbf{if} $(\textit{outcome} = \bot)$ \textbf{then} return($\bot$) \\ \mbox{}
\quad \quad \textbf{elsif} $(\textit{alt} = \bot)$ \textbf{then} return($\textit{outcome}$) \\ \mbox{}
\quad \quad \textbf{else} return($\textit{outcome} \mid \textit{alt}$) \\ \mbox{}
\quad \quad \textbf{fi} \\ \mbox{}
\quad \textbf{fi}


\bibliographystyle{eptcs}
\bibliography{uta}
\end{document}
