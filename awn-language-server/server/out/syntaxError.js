"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syntaxError = void 0;
let literalToString = {
    ' ': '(spacing)',
    '\\n': '(linebreak)',
    '[a-zA-Z0-9]': '(name)',
    '\\(': '(',
    '\\)': ')',
    '\\{': '{',
    '\\}': '}',
    '\\=': '=',
    '\\:\\=': ':=',
    ',': '\",\"'
};
//Given a SyntaxErr generated by the parser, create a nicer error message.
function syntaxError(se) {
    var matchesNice = [];
    const matchesUgly = se.expmatches;
    for (const m of matchesUgly) {
        if (m.kind === "EOF") {
            matchesNice.push("EOF");
        }
        else if (!['\\t', '\\v', '\\r\\n', '\\.', '[\\*\\+-<\\=>\\!\\&|\\\\]+'].includes(m.literal)) { //if \r\n exists, then \n does too. doing this makes the logic easier because then i can map only \n to "linebreak". likewise for \v and \t with ' ', and \. with [a-zA-Z0-9]. we are ignoring infix for now
            const l = m.literal;
            if (l in literalToString) {
                console.log(l);
                matchesNice.push(literalToString[l]);
            }
            else {
                matchesNice.push(l);
            }
        }
    }
    console.log(matchesUgly);
    console.log(matchesNice);
    return `Syntax Error at line ${se.pos.line}, char ${se.pos.offset + 1}.\n Expected one of ${matchesNice.join(', ')}`;
}
exports.syntaxError = syntaxError;
//# sourceMappingURL=syntaxError.js.map