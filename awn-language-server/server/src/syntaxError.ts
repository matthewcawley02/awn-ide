import { SyntaxErr } from './parser'

let literalToString: Record<string, string> = {
	' ': '(spacing)',
	'\\n': '(linebreak)',
	'[a-zA-Z0-9]': '(name)',
	'\\(': '(',
	'\\)': ')',
	'\\{': '{',
	'\\}': '}',
	'\\=': '=',
	'\\:\\=': ':=',
	',': '\",\"'
}

//Given a SyntaxErr generated by the parser, create a nicer error message.
export function syntaxError(se: SyntaxErr): string{
	var matchesNice: string[] = []
	const matchesUgly = se.expmatches
	for (const m of matchesUgly){
		if(m.kind === "EOF"){
			matchesNice.push("EOF")
		}
		else if(!['\\t', '\\v', '\\r\\n', '\\.', '[\\*\\+-<\\=>\\!\\&|\\\\]+'].includes(m.literal)){ //if \r\n exists, then \n does too. doing this makes the logic easier because then i can map only \n to "linebreak". likewise for \v and \t with ' ', and \. with [a-zA-Z0-9]. we are ignoring infix for now
			const l = m.literal
			if(l in literalToString){
				console.log(l)
				matchesNice.push(literalToString[l])
			}else{
				matchesNice.push(l)
			}
		}
	}
	console.log(matchesUgly)
	console.log(matchesNice)
	return `Syntax Error at line ${se.pos.line}, char ${se.pos.offset+1}.\n Expected one of ${matchesNice.join(', ')}`
}